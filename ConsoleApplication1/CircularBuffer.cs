using System;
using System.Collections.Generic;

namespace BufferPlay
{
    public class CircularBuffer<T> : Buffer<T>
    {
        int _capacity;
        public CircularBuffer(int capacity = 10)
        {
            _capacity = capacity;
        }

        public override void Write(T value)
        {
            base.Write(value);
            if(_queue.Count > _capacity)
            {
                // here's where we actually call the event.
                var discard = _queue.Dequeue();
                OnItemDiscarded(discard, value);
            }
        }

        // method stub generated by VS
        // better to have this code here than cluttering up the code above.
        private void OnItemDiscarded(T discard, T value)
        {
            // 1st, check to see if anyone has subscribed. If not, no reason to raise the event.
            if(ItemDiscarded != null)
            {
                var args = new ItemDiscardedEventArgs<T>(discard, value);
                ItemDiscarded(this, args);
            }
        }

        // EventHandler is built into system.
        // Used to have to define a custom delegate, raise event using that delegate type.
        // This is now an event that expects to be handled by 
        // a method that takes an object as its first parameter and eventargs as its second.
        // using the custom EventArgs rather than default so we can pass parameters and have the generic type
        public event EventHandler<ItemDiscardedEventArgs<T>> ItemDiscarded;

        public bool IsFull {  get { return _queue.Count == _capacity; } }
    }

    // need this custom class to make it possible to pass along additional information 
    // since there are no properties to be set with the built-in event args. 
    // derive from EventArgs as a base class, like any good event arguments class

    public class ItemDiscardedEventArgs<T> : EventArgs
    {
        // This is a constructor that requires the discarded item and new item.
        // All it does with them is use them to define those getter/setters
        public ItemDiscardedEventArgs(T discarded, T newitem)
        {
            ItemDiscarded = discarded;
            NewItem = newitem;
        }

        // Expose the item discarded.
        // Using T instead of some type as we don't know what it'll be.
        public T ItemDiscarded { get; set; }
        public T NewItem { get; set; }

    }
} 